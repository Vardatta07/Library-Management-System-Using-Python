    # In-memory "database" — using a name that sounds less formal than `books`
    self.db = []  # list of dicts: {'title': ..., 'author': ..., 'available': True/False}

    # Main container
    frame = tk.Frame(master, bg="#f0f0f0", padx=20, pady=20)
    frame.pack(fill=tk.BOTH, expand=True)

    # Header
    self.header = tk.Label(frame, text="Library Management System", font=("Arial", 18, "bold"),
                           bg="#f0f0f0", fg="#333")
    self.header.pack(pady=10)

    # Button area
    btn_area = tk.Frame(frame, bg="#f0f0f0")
    btn_area.pack(pady=10)

    # Central style dict — humans sometimes forget to update everywhere; kept intentionally simple
    btn_style = {"font": ("Arial", 10), "bg": "#4CAF50", "fg": "white",
                 "relief": tk.RAISED, "bd": 2, "width": 15}

    # Buttons — not all names consistent; humans sometimes name them differently in different places
    self.btn_add = tk.Button(btn_area, text="Add Book", command=self.add_book, **btn_style)
    self.btn_add.grid(row=0, column=0, padx=5, pady=5)

    self.btn_remove = tk.Button(btn_area, text="Remove Book", command=self.remove_book, **btn_style)
    self.btn_remove.grid(row=0, column=1, padx=5, pady=5)

    self.btn_search = tk.Button(btn_area, text="Search Book", command=self.search_book, **btn_style)
    self.btn_search.grid(row=1, column=0, padx=5, pady=5)

    self.btn_display = tk.Button(btn_area, text="Display All Books", command=self.display_books, **btn_style)
    self.btn_display.grid(row=1, column=1, padx=5, pady=5)

    self.btn_borrow = tk.Button(btn_area, text="Borrow Book", command=self.borrow_book, **btn_style)
    self.btn_borrow.grid(row=2, column=0, padx=5, pady=5)

    self.btn_return = tk.Button(btn_area, text="Return Book", command=self.return_book, **btn_style)
    self.btn_return.grid(row=2, column=1, padx=5, pady=5)

    # quit button styled slightly differently — I like bright red for quit
    self.btn_quit = tk.Button(btn_area, text="Quit", command=master.quit,
                              bg="#f44336", fg="white", font=("Arial", 10),
                              relief=tk.RAISED, bd=2, width=15)
    self.btn_quit.grid(row=3, column=0, columnspan=2, pady=10)

    # Text area for listing books. Chose Courier for monospaced look; could switch later
    self.output = tk.Text(frame, height=12, width=80, font=("Courier", 10),
                          bg="#ffffff", fg="#333", relief=tk.SUNKEN, bd=2)
    self.output.pack(pady=10)

# Helper: normalize title for case-insensitive comparison
def _normalize(self, s):
    # small helper, some people forget to handle None — so do a safe check
    if not s:
        return ""
    return s.strip().lower()

# Add a book with simple dialogs
def add_book(self):
    title = simpledialog.askstring("Add Book", "Enter book title:")
    author = simpledialog.askstring("Add Book", "Enter author name:")

    # small redundant check a human might add: keep a local flag even though we could return immediately
    ok = bool(title and author)
    if ok:
        # using intermediate variable for clarity — slightly less concise but more readable for some
        book_entry = {"title": title.strip(), "author": author.strip(), "available": True}
        self.db.append(book_entry)
        # I like confirming actions
        messagebox.showinfo("Success", f"Book '{title}' added successfully!")
    else:
        # Note: user could press cancel; treat it same as missing inputs
        messagebox.showerror("Error", "Title and author are required.")

def remove_book(self):
    title = simpledialog.askstring("Remove Book", "Enter book title to remove:")
    if not title:
        messagebox.showerror("Error", "Title is required.")
        return

    # Slightly clumsy search: iterate and remove (works but humans sometimes do it this way)
    found = False
    for bk in list(self.db):  # using list copy to be safe if we remove while iterating (paranoid but okay)
        if self._normalize(bk.get("title")) == self._normalize(title):
            self.db.remove(bk)
            found = True
            messagebox.showinfo("Success", f"Book '{title}' removed successfully!")
            break

    if not found:
        messagebox.showerror("Error", f"Book '{title}' not found.")

def search_book(self):
    title = simpledialog.askstring("Search Book", "Enter book title to search:")
    if not title:
        messagebox.showerror("Error", "Title is required.")
        return

    # Another common human pattern: two-step (find then display)
    matched = None
    for bk in self.db:
        if self._normalize(bk.get("title")) == self._normalize(title):
            matched = bk
            break

    if matched:
        status = "Available" if matched.get("available", True) else "Borrowed"
        messagebox.showinfo("Book Found", f"Title: {matched['title']}\nAuthor: {matched['author']}\nStatus: {status}")
    else:
        messagebox.showerror("Error", f"Book '{title}' not found.")

def display_books(self):
    # Clear first
    self.output.delete(1.0, tk.END)

    if not self.db:
        # short message — could be prettier, but fine for now
        self.output.insert(tk.END, "No books in the library.\n")
        return

    # A human might format things a bit inconsistently; we'll loop and build a formatted line each time
    for bk in self.db:
        status = "Available" if bk.get("available", True) else "Borrowed"
        line = f"Title: {bk['title']}, Author: {bk['author']}, Status: {status}\n"
        self.output.insert(tk.END, line)

    # Note to self: maybe add sorting later. For now, preserve insertion order.

def borrow_book(self):
    title = simpledialog.askstring("Borrow Book", "Enter book title to borrow:")
    if not title:
        messagebox.showerror("Error", "Title is required.")
        return

    # intentionally slightly verbose: check availability and then update
    for bk in self.db:
        if self._normalize(bk.get("title")) == self._normalize(title):
            if bk.get("available", True):
                # unnecessary local var — demonstrates a non-optimized style a human might write
                was_available = bk["available"]
                bk["available"] = False
                # double-check (redundant) — humans sometimes leave these sanity checks
                if was_available and not bk["available"]:
                    messagebox.showinfo("Success", f"Book '{title}' borrowed successfully!")
                else:
                    # shouldn't happen but keep a fallback message
                    messagebox.showinfo("Note", "Updated status, but check state if this looks wrong.")
            else:
                messagebox.showerror("Error", f"Book '{title}' is already borrowed.")
            return

    messagebox.showerror("Error", f"Book '{title}' not found.")

def return_book(self):
    title = simpledialog.askstring("Return Book", "Enter book title to return:")
    if not title:
        messagebox.showerror("Error", "Title is required.")
        return

    for bk in self.db:
        if self._normalize(bk.get("title")) == self._normalize(title):
            if not bk.get("available", True):
                bk["available"] = True
                messagebox.showinfo("Success", f"Book '{title}' returned successfully!")
            else:
                messagebox.showerror("Error", f"Book '{title}' was not borrowed.")
            return

    messagebox.showerror("Error", f"Book '{title}' not found.")
